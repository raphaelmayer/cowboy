/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Controller.js":
/*!***************************!*\
  !*** ./src/Controller.js ***!
  \***************************/
/*! exports provided: handleMouseDown, handleMouseUp, handleMouseMove, handleLeftClick, handleRightClick, handleKeyDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleMouseDown\", function() { return handleMouseDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleMouseUp\", function() { return handleMouseUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleMouseMove\", function() { return handleMouseMove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleLeftClick\", function() { return handleLeftClick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleRightClick\", function() { return handleRightClick; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"handleKeyDown\", function() { return handleKeyDown; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _classes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes.js */ \"./src/classes.js\");\n\r\n\r\n\r\n\r\n // der import gh√∂rt auf jeden fall weg\r\n\r\n\r\nfunction handleMouseDown(event, gs) {\r\n    // leftMousePressed = true;\r\n}\r\n\r\nfunction handleMouseUp(event, gs) {\r\n\r\n}\r\n\r\nfunction handleMouseMove(event, gs) {\r\n\r\n    gs.set(\"mousePos\", \"x\", event.x);\r\n    gs.set(\"mousePos\", \"y\", event.y);\r\n}\r\n\r\nfunction handleLeftClick(event, gs) {\r\n    if (event.button === 2) return; // prevent right click from firing this\r\n\r\n    console.log(\"left\", event);\r\n    console.log(gs.get(\"currentSelection\"));\r\n\r\n    // leftMousePressed = !leftMousePressed;\r\n\r\n    // handle tile selection\r\n    // check entities first\r\n    let entityFound = false; // hack to prevent tile selection loop from running\r\n    for (let i = 0; i < gs.get(\"entities\").length; i++) {\r\n        const e = gs.get(\"entities\", i);\r\n\r\n        // only if tile has entity\r\n        if (Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(e.x) === Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(event.x) && Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(e.y) === Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(event.y)) {\r\n            if (gs.get(\"mode\") === _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"ATTACK_MODE\"]) {\r\n                console.log(\"target\");\r\n\r\n                // check if within range\r\n                const { x, y, range, weapon } = gs.get(\"currentSelection\");\r\n                if (Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileDistance\"])(x, y, e.x, e.y) < range) {\r\n                    // shoot entity\r\n                    const bullet = Object(_classes_js__WEBPACK_IMPORTED_MODULE_2__[\"projectile\"])({\r\n                        x, y,\r\n                        targetX: e.x, targetY: e.y,\r\n                        animate: (velocity) => {\r\n                            // velocity in tile / second\r\n                            console.log(\"bullet animate\")\r\n                            const steps = 100;\r\n                            const distance = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileDistance\"])(x, y, e.x, e.y);\r\n                            const duration = distance / velocity;\r\n                            console.log(\"distance:\", distance, \"tiles, duration:\", duration, \"s\");\r\n\r\n                            let collided = false;\r\n                            const dx = e.x - x;\r\n                            const dy = e.y - y;\r\n                            for (let i = 0, j = 1; i < duration; i += (duration / steps), j++) {\r\n                                setTimeout(() => {\r\n                                    if (!gs.get(\"screen_buffer\")[Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(bullet.x, bullet.y)].traversable) {\r\n                                        console.log(\"bullet stopped\");\r\n                                        collided = true;\r\n                                        return;\r\n                                    }\r\n                                    // console.log(\"dx \" + dx + \", dy \" + dy)\r\n                                    bullet.x += dx / steps;\r\n                                    bullet.y += dy / steps;\r\n                                }, j * (duration / steps) * 1000);\r\n                            }\r\n\r\n                            setTimeout(() => !collided && gs.get(\"entities\").splice(i, 1), duration * 1000);\r\n\r\n\r\n                        }\r\n                    });\r\n                    gs.get(\"entities\").push(bullet); // spawn bullet\r\n                    // bullet.animate(500, 10);\r\n                    bullet.animate(weapon.velocity);\r\n\r\n                    // entities.splice(i, 1); // remove entity\r\n                    console.log(gs.get(\"entities\"));\r\n                }\r\n            } else {\r\n                console.log(\"select entity\");\r\n                gs.set(\"mode\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"STANDARD_MODE\"]);\r\n                gs.set(\"currentSelection\", e);\r\n            }\r\n\r\n            // // close attack mode / return to standard mode\r\n            // while (overlays.length > 0)\r\n            //     overlays.pop();\r\n            // // naja eig kannt ma ja scho ruhig weiterballern\r\n            // mode = STANDARD_MODE;\r\n            entityFound = true;\r\n        } else {\r\n        }\r\n    }\r\n\r\n    if (!entityFound) console.log(\"no entity\");\r\n\r\n    // else select building\r\n\r\n    // else select tile\r\n    // if attack mode, keep currently selected entity and continue\r\n    if (!entityFound && gs.get(\"mode\") !== _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"ATTACK_MODE\"]) {\r\n        const i = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(event.x, event.y);\r\n        gs.set(\"currentSelection\", gs.get(\"screen_buffer\")[i]);\r\n    }\r\n\r\n    // highlght selection (machma sp√§ter)\r\n    // if (leftMousePressed) {\r\n    //     leftMouseDownStart = { x: event.x, y: event.y };\r\n    //     preview.push({\r\n    //         x: toTileSize(event.x) * TILE_SIZE,\r\n    //         y: toTileSize(event.y) * TILE_SIZE,\r\n    //         data: [],\r\n    //         color: \"#\" + rand(100).toFixed(0) + rand(100).toFixed(0) + rand(100).toFixed(0)\r\n    //     });\r\n    // } else {\r\n    //     leftMouseDownStart = null;\r\n    //     // currentSelection = null; // geht nied, wiel click down und up is\r\n\r\n    //     // while (preview.length > 0) {\r\n    //     //     screen_buffer.push(preview.pop());\r\n    //     // }\r\n    // }\r\n}\r\n\r\nfunction handleRightClick(event, gs) {\r\n    event.preventDefault();\r\n    console.log(\"right\", event);\r\n    const { x, y, moveTo, friendly } = gs.get(\"currentSelection\");\r\n\r\n    if (friendly === 1) {\r\n        // currentSelection.x = toTileSize(event.x) * TILE_SIZE;\r\n        // currentSelection.y = toTileSize(event.y) * TILE_SIZE;\r\n\r\n        moveTo && moveTo(x, y, Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(event.x) * TILE_SIZE, Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(event.y) * TILE_SIZE, 5);\r\n    }\r\n}\r\n\r\nfunction handleKeyDown(event, gs) {\r\n    // const { overlays, screen_buffer, currentSelection } = gs;\r\n    // let { debug } = gs;\r\n\r\n    console.log(event.code);\r\n    // if (!currentSelection || !currentSelection.movementSpeed) return;\r\n\r\n    if (event.code !== \"Digit1\") {\r\n        while (gs.get(\"overlays\").length > 0)\r\n            gs.set(\"overlays\", []);\r\n        gs.set(\"mode\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"STANDARD_MODE\"]);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} duration \r\n     * @param {*} steps \r\n     * @param {*} animFunction \r\n     */\r\n    function animateWalk(tile, duration, steps, animFunction) {\r\n        for (let i = 0; i < duration; i += (duration / steps)) {\r\n            setTimeout(() => {\r\n                animFunction();\r\n                // if (i > duration - 2 * (duration / steps))\r\n                //     console.log(\"tile:\", tile);\r\n                // tile.occupied = true;\r\n            }, i);\r\n        }\r\n    }\r\n    function wouldCollide(entity, code) {\r\n        if (!entity || !entity.movementSpeed) return true;\r\n        const x = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(entity.x);\r\n        const y = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"toTileSize\"])(entity.y);\r\n        let toX = 0;\r\n        let toY = 0;\r\n\r\n        if (code === \"KeyW\") toY = -1;\r\n        if (code === \"KeyS\") toY = 1;\r\n        if (code === \"KeyA\") toX = -1;\r\n        if (code === \"KeyD\") toX = 1;\r\n\r\n        // falls mir schon in bewegung sind nach rechts oder unten, isses toTileSize\r\n        // nat√ºrlich immer no links oben, sollt aber eig die kollision vom tile aus\r\n        // checken, des eins weiter rechts bzw unten is.\r\n        if (x * TILE_SIZE < entity.x) ++toX;\r\n        if (y * TILE_SIZE < entity.y) ++toY;\r\n\r\n\r\n        const i = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getIndex\"])(x + toX, y + toY, TM_WIDTH); // index of next tile\r\n        console.log(\"x:\", x, \"y:\", y, \" => i:\", i);\r\n\r\n        // needs to check entities aswell; either look into entities or screen buffer.occupied\r\n        const tile = gs.get(\"screen_buffer\")[i];\r\n        if (!tile.traversable || tile.occupied) {\r\n            console.log(\"collision detected:\", tile);\r\n            console.log(\"entity:\", entity);\r\n            // drawSprite(screen_buffer[i], bgcontext);\r\n            return true;\r\n        }\r\n        // getIndex weil x, y oben scho toTileSize() \r\n        const j = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getIndex\"])(x, y, TM_WIDTH); // index of current tile\r\n        console.log(i, j)\r\n        gs.get(\"screen_buffer\")[j].occupied = false;\r\n        // screen_buffer[i].occupied = true;\r\n        return false;\r\n    }\r\n\r\n    switch (event.code) {\r\n        case \"KeyW\":\r\n            if (!wouldCollide(gs.get(\"currentSelection\"), event.code))\r\n                animateWalk(\r\n                    gs.get(\"screen_buffer\")[Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(gs.get(\"currentSelection\").x, gs.get(\"currentSelection\").y - TILE_SIZE)],\r\n                    200, TILE_SIZE, () => gs.set(\"currentSelection\", \"y\", gs.get(\"currentSelection\").y - 1));\r\n            // animateWalk(200, 20, () => gs.get(\"currentSelection\").y += -TILE_SIZE / 20);\r\n            break;\r\n        case \"KeyD\":\r\n            if (!wouldCollide(gs.get(\"currentSelection\"), event.code))\r\n                animateWalk(\r\n                    gs.get(\"screen_buffer\")[Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(gs.get(\"currentSelection\").x + TILE_SIZE, gs.get(\"currentSelection\").y)],\r\n                    200, TILE_SIZE, () => gs.set(\"currentSelection\", \"x\", gs.get(\"currentSelection\").x + 1));\r\n            // animateWalk(200, 20, () => gs.get(\"currentSelection\").x += TILE_SIZE / 20);\r\n            break;\r\n        case \"KeyS\":\r\n            if (!wouldCollide(gs.get(\"currentSelection\"), event.code))\r\n                animateWalk(\r\n                    gs.get(\"screen_buffer\")[Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(gs.get(\"currentSelection\").x, gs.get(\"currentSelection\").y + TILE_SIZE)],\r\n                    200, TILE_SIZE, () => gs.set(\"currentSelection\", \"y\", gs.get(\"currentSelection\").y + 1));\r\n            // animateWalk(200, 20, () => gs.get(\"currentSelection\").y += TILE_SIZE / 20);\r\n            break;\r\n        case \"KeyA\":\r\n            if (!wouldCollide(gs.get(\"currentSelection\"), event.code))\r\n                animateWalk(\r\n                    gs.get(\"screen_buffer\")[Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileIndex\"])(gs.get(\"currentSelection\").x - TILE_SIZE, gs.get(\"currentSelection\").y)],\r\n                    200, TILE_SIZE, () => gs.set(\"currentSelection\", \"x\", gs.get(\"currentSelection\").x - 1));\r\n            // animateWalk(200, 20, () => gs.get(\"currentSelection\").x += -TILE_SIZE / 20);\r\n            break;\r\n        case \"Digit1\": // attack mode\r\n            console.log(\"attack mode\");\r\n\r\n            while (gs.get(\"overlays\").length > 0)\r\n                gs.set(\"overlays\", []);\r\n\r\n            if (!gs.get(\"currentSelection\") || gs.get(\"mode\") === _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"ATTACK_MODE\"]) {\r\n                gs.set(\"mode\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"STANDARD_MODE\"]);\r\n            } else {\r\n                gs.set(\"mode\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"ATTACK_MODE\"]);\r\n                const { x, y, range } = gs.get(\"currentSelection\");\r\n                for (let i = -range; i < range; i++) {\r\n                    for (let j = -range; j < range; j++)\r\n                        if (Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"getTileDistance\"])(x, y, x + i * TILE_SIZE, y + j * TILE_SIZE) < range)\r\n                            gs.get(\"overlays\").push({ x: x + i * TILE_SIZE, y: y + j * TILE_SIZE });\r\n                }\r\n            }\r\n            break;\r\n        case \"Digit2\":\r\n            break;\r\n        case \"Digit3\":\r\n            break;\r\n        case \"Digit4\":\r\n            gs.set(\"currentSelection\", \"x\", gs.get(\"currentSelection\", \"x\") + 20);\r\n            break;\r\n        case \"Digit0\":\r\n            console.log(gs);\r\n            gs.get(\"debug\") === 0 ? gs.set(\"debug\", 5) : gs.set(\"debug\", gs.get(\"debug\") - 1);\r\n            break;\r\n    }\r\n}\n\n//# sourceURL=webpack:///./src/Controller.js?");

/***/ }),

/***/ "./src/GameState.js":
/*!**************************!*\
  !*** ./src/GameState.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GameState; });\nclass GameState {\r\n    constructor() {\r\n        this.screen_buffer = []; // holds tiles objects\r\n        this.entities = []; // holds entities\r\n        this.overlays = []; // holds overlays\r\n        this.weatherParticles = [];\r\n        this.lightning = 5;\r\n        this.fogOfWar = [];\r\n\r\n        this.mode = \"STANDARD_MODE\";\r\n        this.currentSelection;\r\n        this.mousePos = { x: 0, y: 0 };\r\n        this.mapInitialized = false; // as to only load static tiles once\r\n        this.debug = 5;\r\n\r\n        this.preview = [];\r\n        this.pressedKeys = {};\r\n        this.leftMousePressed = false;\r\n        this.leftMouseDownStart = null;\r\n        this.timePreviousFrame;\r\n        this.fps = 0;\r\n    }\r\n    get(key, subkey) {\r\n        if (subkey || subkey === 0)\r\n            return this[key][subkey];\r\n        return this[key];\r\n    }\r\n    set(key, subkey, value) {\r\n        if (value || value === 0) // subkey is optional and could be missing\r\n            this[key][subkey] = value;\r\n        else\r\n            this[key] = subkey;\r\n    }\r\n    // fill method f√ºr arrays ?\r\n}\r\n\r\n// const gs = new GameState();\r\n\r\n// gs.set(\"debug\", 13);\r\n// gs.set(\"preview\", 0, 13);\r\n// console.log(gs.get(\"debug\"));\r\n// console.log(gs.get(\"preview\"));\r\n// gs.get(\"preview\").push(1,2,3);\r\n// console.log(gs.get(\"preview\"));\r\n\n\n//# sourceURL=webpack:///./src/GameState.js?");

/***/ }),

/***/ "./src/classes.js":
/*!************************!*\
  !*** ./src/classes.js ***!
  \************************/
/*! exports provided: gameObject, tile, floor, wall, halfwall, highgrass, entity, soldier, gunner, sniper, chicken, projectile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gameObject\", function() { return gameObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tile\", function() { return tile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wall\", function() { return wall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"halfwall\", function() { return halfwall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"highgrass\", function() { return highgrass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"entity\", function() { return entity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"soldier\", function() { return soldier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gunner\", function() { return gunner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sniper\", function() { return sniper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chicken\", function() { return chicken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projectile\", function() { return projectile; });\n/**\r\n * Tile object with dimensions x = x / TILE_SIZE, y = y / TILE_SIZE\r\n * @param {Float} x \r\n * @param {Float} y \r\n */\r\nfunction gameObject({ x, y, name, color, sprite }) {\r\n    return {\r\n        x, y, name: name || \"null\", \r\n        sprite: sprite || { x: 6, y: 2 }, \r\n        color: color || \"red\"\r\n    }\r\n}\r\n\r\nfunction tile({ x, y, name, color, sprite, traversable, penetrable, seeable, occupied, movementCost }) {\r\n    return {\r\n        ...gameObject({ x, y, name, color, sprite }),\r\n        traversable: traversable, // can creatures move through\r\n        penetrable: penetrable, // can projectiles move through\r\n        seeable: seeable, // can projectiles move through\r\n        occupied: occupied === true ? true : false, // is a unit on the tile (eig woll ma de static objects ja nied √§ndern)\r\n        // hasBuilding: occupied === true ? true : false, // does tile already have building\r\n        movementCost: movementCost || 1\r\n    }\r\n}\r\n\r\nfunction floor({ x, y, name, sprite, movementCost }) {\r\n    return {\r\n        ...tile({\r\n            x, y, name, color: \"white\",\r\n            traversable: true, penetrable: true, seeable: true,\r\n            movementCost: movementCost || 1,\r\n            sprite\r\n        }),\r\n    }\r\n}\r\nfunction wall({ x, y, name, sprite, movementCost }) {\r\n    return {\r\n        ...tile({\r\n            x, y, name, color: \"grey\",\r\n            traversable: false, penetrable: false, seeable: false,\r\n            movementCost: movementCost || 1,\r\n            sprite\r\n        }),\r\n    }\r\n}\r\nfunction halfwall({ x, y, name, sprite, movementCost }) {\r\n    return {\r\n        ...tile({\r\n            x, y, name, color: \"lightgrey\",\r\n            traversable: true, penetrable: false, seeable: true,\r\n            movementCost: movementCost || 2,\r\n            sprite\r\n        })\r\n    }\r\n}\r\nfunction highgrass({ x, y, name, sprite, movementCost }) {\r\n    return {\r\n        ...tile({\r\n            x, y, name, color: \"darkgreen\",\r\n            traversable: true, penetrable: true, seeable: false,\r\n            movementCost: movementCost || 2,\r\n            sprite\r\n        })\r\n    }\r\n}\r\n\r\nfunction entity({ x, y, name, color, sprite, movementSpeed, friendly, vision }) {\r\n    return {\r\n        ...gameObject({ x, y, name, color, sprite }),\r\n        draw: null, // not in use; array of entities gets drawn to screen by coordinates\r\n        movementSpeed,\r\n        friendly: friendly ? friendly : 0, // enemy: -1, neutral: 0, friendly: 1\r\n        vision: vision || 10,\r\n        xVel: 0,\r\n        yVel: 0,\r\n\r\n        moveTo: (sx, sy, ex, ey, velocity) => {\r\n            this.xVel += ex - sx;\r\n            this.yVel += ey - sy;\r\n            // // velocity in tile / second\r\n            // const steps = 100;\r\n            // const distance = getTileDistance(sx, sy, ex, ey);\r\n            // const duration = distance / velocity;\r\n            // console.log(\"distance:\", distance, \"tiles, duration:\", duration, \"s\");\r\n\r\n            // const dx = ex - sx;\r\n            // const dy = ey - sy;\r\n\r\n            // for (let i = 0, j = 1; i < duration; i += (duration  / steps), j++) {\r\n            //     setTimeout(() => {\r\n            //         // console.log(\"dx \" + dx + \", dy \" + dy)\r\n            //         this.x += dx  / steps;\r\n            //         this.y += dy  / steps;\r\n            //     }, j * (duration  / steps) * 1000);\r\n            // }\r\n        }\r\n    };\r\n}\r\n\r\nfunction soldier({ x, y, name, color, sprite, range, movementSpeed, friendly }) {\r\n    movementSpeed = 4;\r\n    return {\r\n        ...entity({ x, y, name, color, sprite, movementSpeed, friendly }),\r\n        // health: 10,\r\n        // attack: 10, // eigentlich gun stats\r\n        range: (range || range === 0) ? range : 10, // eigentlich gun stats\r\n        // attackSpeed: 1, // eigentlich gun stats\r\n        // shoot: null // ?\r\n        // weapon?\r\n        // hory shiet da kommt no viel\r\n    };\r\n}\r\n\r\nfunction gunner({ x, y, name, sprite, friendly }) {\r\n    return {\r\n        ...soldier({\r\n            x, y, name, friendly,\r\n            sprite: sprite || { x: 0, y: 1 },\r\n            range: 10,\r\n            movementSpeed: 5,\r\n            name: \"gunner\",\r\n        }),\r\n        weapon: {\r\n            attack: 5,\r\n            velocity: 10,\r\n        }\r\n    }\r\n}\r\n\r\nfunction sniper({ x, y, friendly }) {\r\n    return {\r\n        ...soldier({\r\n            x, y, friendly,\r\n            sprite: { x: 3, y: 2 },\r\n            range: 20,\r\n            movementSpeed: 3,\r\n            name: \"sniper\",\r\n        }),\r\n        weapon: {\r\n            attack: 10,\r\n            velocity: 20,\r\n        }\r\n    }\r\n}\r\n\r\nfunction chicken({ x, y, name }) {\r\n    return {\r\n        ...entity({ x, y, name: \"chicken\", sprite: { x: 2, y: 1 }, movementSpeed: 3 })\r\n    }\r\n}\r\n\r\nfunction projectile({ x, y, sprite, targetX, targetY, animate }) {\r\n    sprite = sprite || { x: 5, y: 0 };\r\n    return {\r\n        ...entity({ x, y, sprite }),\r\n        targetX,\r\n        targetY,\r\n        animate: animate || null\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/classes.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: STANDARD_MODE, ATTACK_MODE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STANDARD_MODE\", function() { return STANDARD_MODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ATTACK_MODE\", function() { return ATTACK_MODE; });\nconst STANDARD_MODE = \"STD\";\r\nconst ATTACK_MODE = \"ATK\";\n\n//# sourceURL=webpack:///./src/constants.js?");

/***/ }),

/***/ "./src/cowboy.js":
/*!***********************!*\
  !*** ./src/cowboy.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return main; });\n/* harmony import */ var _classes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes.js */ \"./src/classes.js\");\n/* harmony import */ var _Controller_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Controller.js */ \"./src/Controller.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./src/util.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n/* harmony import */ var _GameState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameState.js */ \"./src/GameState.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\"use strict\";\r\n\r\nconst spriteSheet = new Image(40, 20);\r\nspriteSheet.src = \"./sprite-sheet.png\";\r\nconst AMBIENT_COLOR = \"#e1c699\"; // \"#191970\"; // midnight blue\r\n\r\nlet MAP_TEMPLATE = \"\";\r\n\r\nMAP_TEMPLATE += \"#####################H##########\";\r\nMAP_TEMPLATE += \"#hhhhhhhhhhhhhh#     Hhhhhhhhhh#\";\r\nMAP_TEMPLATE += \"#hhhh       hhh#     H   hhhhhh#\";\r\nMAP_TEMPLATE += \"#hh           h  z  zH     hhhh#\";\r\nMAP_TEMPLATE += \"#hh   ------      uu H      -hh#\";\r\nMAP_TEMPLATE += \"#hh  hh####-    --   H      -hh#\";\r\nMAP_TEMPLATE += \"#hh   h####-   ---hh H     -hhh#\";\r\nMAP_TEMPLATE += \"#hh   h hhH    --hhhhH    -hhhh#\";\r\nMAP_TEMPLATE += \"==========X==========X==========\";\r\nMAP_TEMPLATE += \"#####     H    hhhh  H 6   hhhh#\";\r\nMAP_TEMPLATE += \"#h        H     hh   H      hhh#\";\r\nMAP_TEMPLATE += \"#h  1223h Hh123      H       ###\";\r\nMAP_TEMPLATE += \"#h  qwweh Hhqwe      H        h#\";\r\nMAP_TEMPLATE += \"#h  assdh Hhqwe      H #  --  h#\";\r\nMAP_TEMPLATE += \"#h hyxfch Hhqwe   h  H # ---  h#\";\r\nMAP_TEMPLATE += \"#h        Hhqwe      H # --  hh#\";\r\nMAP_TEMPLATE += \"#h  12223 Hhqwe      H      hhh#\";\r\nMAP_TEMPLATE += \"#h  qwwwe Hhqwe    --H      hhh#\";\r\nMAP_TEMPLATE += \"#h  asssd Hhasd   ---H      hhh#\";\r\nMAP_TEMPLATE += \"#h hyxgfc Hhyxc   ---H     --hh#\";\r\nMAP_TEMPLATE += \"==========L==========X=========-\";\r\nMAP_TEMPLATE += \"#h            #      H   ---hhh#\";\r\nMAP_TEMPLATE += \"#hhhhhhhhhhhhh#hhhhh H ----hhhh#\";\r\nMAP_TEMPLATE += \"#####################H##########\";\r\n\r\n\r\nfunction main() {\r\n    // canvas shit\r\n    const canvas = document.createElement(\"canvas\");\r\n    const bgcanvas = document.createElement(\"canvas\");\r\n    canvas.width = bgcanvas.width = WINDOW_WIDTH;\r\n    canvas.height = bgcanvas.height = WINDOW_HEIGHT;\r\n    canvas.style.position = bgcanvas.style.position = \"absolute\";\r\n    document.body.style.margin = 0;\r\n    document.body.insertBefore(canvas, document.body.childNodes[0]);\r\n    document.body.insertBefore(bgcanvas, document.body.childNodes[0]);\r\n    const context = canvas.getContext(\"2d\");\r\n    const bgcontext = bgcanvas.getContext(\"2d\");\r\n    // const imageData = context.createImageData(WINDOW_WIDTH, WINDOW_HEIGHT);\r\n\r\n    // game state data structures\r\n    const gs = new _GameState_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\r\n\r\n\r\n    for (let i = 0; i < TM_WIDTH * 4; i++) {\r\n        gs.get(\"weatherParticles\").push({ x: Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"rand\"])(WINDOW_WIDTH), y: -Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"rand\"])(WINDOW_HEIGHT) })\r\n    }\r\n\r\n    console.log(\"resolution: \" + WINDOW_WIDTH + \" * \" + WINDOW_HEIGHT)\r\n    console.log(\"tile size: \" + TILE_SIZE + \", tile resolution: \" + TM_WIDTH + \" * \" + WINDOW_HEIGHT / TILE_SIZE)\r\n\r\n    // load map\r\n    console.log(\"MAP_CHAR_COUNT:\", MAP_TEMPLATE.length);\r\n    for (let i = 0; i < MAP_TEMPLATE.length - 1; i++) {\r\n        const { x, y } = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"convert1dto2d\"])(i, TM_WIDTH);\r\n        if (MAP_TEMPLATE[i] == \" \")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"grass tile\", sprite: { x: 0, y: 0 } }) });\r\n        if (MAP_TEMPLATE[i] == \"-\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"highgrass\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"high grass tile\", sprite: { x: 7, y: 2 } }) });\r\n        if (MAP_TEMPLATE[i] == \"#\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"wall tile\", sprite: { x: 1, y: 0 } }) });\r\n        if (MAP_TEMPLATE[i] == \"h\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"tree\", sprite: { x: 2, y: 0 } }) });\r\n        if (MAP_TEMPLATE[i] == \"=\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"road\", sprite: { x: 4, y: 0 } }) });\r\n        if (MAP_TEMPLATE[i] == \"H\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"road\", sprite: { x: 3, y: 1 } }) });\r\n        if (MAP_TEMPLATE[i] == \"l\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"road\", sprite: { x: 5, y: 1 } }) });\r\n        if (MAP_TEMPLATE[i] == \"L\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"road\", sprite: { x: 4, y: 2 } }) });\r\n        if (MAP_TEMPLATE[i] == \"X\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"road\", sprite: { x: 3, y: 0 } }) });\r\n\r\n        // house\r\n        if (MAP_TEMPLATE[i] == \"1\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 0, y: 2 } }) });\r\n        if (MAP_TEMPLATE[i] == \"2\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 1, y: 2 } }) });\r\n        if (MAP_TEMPLATE[i] == \"3\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 2, y: 2 } }) });\r\n        if (MAP_TEMPLATE[i] == \"6\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"deer stand\", sprite: { x: 6, y: 0 } }) });\r\n        if (MAP_TEMPLATE[i] == \"7\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 7, y: 0 } }) });\r\n\r\n        if (MAP_TEMPLATE[i] == \"q\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 0, y: 3 } }) });\r\n        if (MAP_TEMPLATE[i] == \"w\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 1, y: 3 } }) });\r\n        if (MAP_TEMPLATE[i] == \"e\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 2, y: 3 } }) });\r\n        if (MAP_TEMPLATE[i] == \"r\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 3, y: 3 } }) });\r\n        if (MAP_TEMPLATE[i] == \"t\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 4, y: 3 } }) });\r\n        if (MAP_TEMPLATE[i] == \"z\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"halfwall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"halfwall H\", sprite: { x: 6, y: 1 } }) });\r\n        if (MAP_TEMPLATE[i] == \"u\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"halfwall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"halfwall V\", sprite: { x: 7, y: 1 } }) });\r\n\r\n        if (MAP_TEMPLATE[i] == \"a\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 0, y: 4 } }) });\r\n        if (MAP_TEMPLATE[i] == \"s\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 1, y: 4 } }) });\r\n        if (MAP_TEMPLATE[i] == \"d\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 2, y: 4 } }) });\r\n        if (MAP_TEMPLATE[i] == \"f\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 3, y: 4 } }) });\r\n        if (MAP_TEMPLATE[i] == \"g\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 4, y: 4 } }) });\r\n\r\n        if (MAP_TEMPLATE[i] == \"y\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 0, y: 5 } }) });\r\n        if (MAP_TEMPLATE[i] == \"x\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"floor\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 1, y: 5 } }) });\r\n        if (MAP_TEMPLATE[i] == \"c\")\r\n            gs.set(\"screen_buffer\", i, { ..._classes_js__WEBPACK_IMPORTED_MODULE_0__[\"wall\"]({ x: x * TILE_SIZE, y: y * TILE_SIZE, name: \"house\", sprite: { x: 2, y: 5 } }) });\r\n    }\r\n    //screen_buffer.forEach(tile => drawSprite(tile, bgcontext));\r\n\r\n    // load entities\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"gunner\"]({ x: 21 * TILE_SIZE, y: 15 * TILE_SIZE, friendly: 1 }));\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"gunner\"]({ x: 15 * TILE_SIZE, y: 15 * TILE_SIZE, sprite: { x: 1, y: 1 }, friendly: 1 }));\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"gunner\"]({ x: 21 * TILE_SIZE, y: 20 * TILE_SIZE, friendly: 1 }));\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"gunner\"]({ x: 15 * TILE_SIZE, y: 20 * TILE_SIZE, sprite: { x: 1, y: 1 }, friendly: 1 }));\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"sniper\"]({ x: 5 * TILE_SIZE, y: 4 * TILE_SIZE, friendly: -1 }));\r\n    gs.get(\"entities\").push(_classes_js__WEBPACK_IMPORTED_MODULE_0__[\"chicken\"]({ x: 10 * TILE_SIZE, y: 12 * TILE_SIZE }));\r\n\r\n    // for (let i = 0; i < 32; i++) {\r\n    //     gs.get(\"entities\").push(cl.gunner({ x: TILE_SIZE * i, y: TILE_SIZE, sprite: { x: 1, y: 1 } }));\r\n    //     gs.get(\"entities\").push(cl.gunner({ x: TILE_SIZE * i, y: TILE_SIZE * 2, sprite: { x: 1, y: 1 } }));\r\n    //     gs.get(\"entities\").push(cl.gunner({ x: TILE_SIZE * i, y: TILE_SIZE * 3, sprite: { x: 1, y: 1 } }));\r\n    //     gs.get(\"entities\").push(cl.gunner({ x: TILE_SIZE * i, y: TILE_SIZE * 4, sprite: { x: 1, y: 1 } }));\r\n    // }\r\n\r\n    // draw screen buffer\r\n    if (!gs.get(\"mapInitialized\")) {\r\n        bgcontext.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n        bgcontext.fillStyle = AMBIENT_COLOR; // set background color\r\n        bgcontext.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n\r\n\r\n        drawTilemap();\r\n        // screen_buffer.forEach(tile => {\r\n        //     drawSprite(tile, bgcontext);\r\n        // });\r\n        gs.set(\"mapInitialized\", true);\r\n    }\r\n\r\n    // also ob de √ºberhaupt nice is und nied einfach drawSprite besser w√§r\r\n    function drawTilemap() {\r\n        gs.get(\"screen_buffer\").forEach((tile, i) => {\r\n            // i is in tile units\r\n            const x = Math.floor(i % (TM_WIDTH)) * TILE_SIZE;\r\n            const y = Math.floor(i / (TM_WIDTH)) * TILE_SIZE;\r\n            bgcontext.drawImage(spriteSheet, TILE_SIZE * tile.sprite.x, TILE_SIZE * tile.sprite.y, TILE_SIZE, TILE_SIZE, x, y, TILE_SIZE, TILE_SIZE);\r\n        });\r\n    }\r\n    \r\n    \r\n    window.onkeyup = function (e) { gs.set(\"pressedKeys\", [e.keyCode], false); }\r\n    window.onkeydown = function (e) { gs.set(\"pressedKeys\", [e.keyCode], true); }\r\n\r\n    let keydown_event = document.addEventListener(\"keydown\", e => _Controller_js__WEBPACK_IMPORTED_MODULE_1__[\"handleKeyDown\"](e, gs));\r\n    let mousemove_event = document.addEventListener(\"mousemove\", e => _Controller_js__WEBPACK_IMPORTED_MODULE_1__[\"handleMouseMove\"](e, gs));\r\n    // let mousedown_event = document.addEventListener(\"mousedown\", handleLeftClick);\r\n    let mouseup_event = document.addEventListener(\"mouseup\", e => _Controller_js__WEBPACK_IMPORTED_MODULE_1__[\"handleLeftClick\"](e, gs));\r\n    let rightclick_event = document.addEventListener('contextmenu', e => _Controller_js__WEBPACK_IMPORTED_MODULE_1__[\"handleRightClick\"](e, gs)); // Right click\r\n    window.requestAnimationFrame(update);\r\n\r\n\r\n    function update() {\r\n        // console.log(\"update\")\r\n        context.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n        // context.fillStyle = AMBIENT_COLOR; // set background color\r\n        // context.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n\r\n        // fps counter (braucht 2 main variablen)\r\n        function getFps() {\r\n            const now = performance.now();\r\n            const prev = gs.get(\"timePreviousFrame\");\r\n            if (!prev) {\r\n                gs.set(\"timePreviousFrame\", now);\r\n                gs.set(\"fps\", 0);\r\n                return;\r\n            }\r\n            let delta = (now - prev) / 1000;\r\n            gs.set(\"timePreviousFrame\", now);\r\n            gs.set(\"fps\", (1 / delta).toFixed(0));\r\n        }\r\n        getFps();\r\n\r\n        // fog of war attempt\r\n        // const visibleTiles = [];\r\n        // entities.forEach(e => {\r\n        //     if (e.friendly === 1) {\r\n        //         getTilesWithinDistance(e.x, e.y, e.vision).forEach(tile => visibleTiles.push(tile));\r\n        //     }\r\n        // });\r\n        // // bgcontext.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n        // // bgcontext.fillStyle = \"black\"; // set background color\r\n        // bgcontext.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n        // visibleTiles.forEach(tile => {\r\n        //     drawSprite(screen_buffer[getTileIndex(tile.x, tile.y)], bgcontext);\r\n        //     // bgcontext.fillStyle = \"black\"; // set background color\r\n        //     // bgcontext.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n        // });\r\n\r\n\r\n        // set all tiles to unoccupied and then go through entities and set occupied accordingly.\r\n        // not sure about doing it on each frame, but having it in wouldCollide and animateWalk sucks balls\r\n        gs.get(\"screen_buffer\").forEach(tile => tile.occupied = false);\r\n\r\n        // draw debug info\r\n        const debug = gs.get(\"debug\");\r\n        if (debug) {\r\n            const { x, y } = gs.get(\"mousePos\");\r\n            context.font = \"10px Arial\";\r\n            // go through different debug overlays\r\n            if (debug === 4) {\r\n                gs.get(\"screen_buffer\").forEach(tile => {\r\n                    context.fillStyle = tile.traversable ? \"green\" : \"red\";\r\n                    context.fillText(\"T\", tile.x, tile.y + 10);\r\n                    context.fillStyle = tile.occupied ? \"green\" : \"red\";\r\n                    context.fillText(\"O\", tile.x + 10, tile.y + 10);\r\n                    context.fillStyle = tile.penetrable ? \"green\" : \"red\";\r\n                    context.fillText(\"P\", tile.x, tile.y + 20);\r\n                    context.fillStyle = tile.seeable ? \"green\" : \"red\";\r\n                    context.fillText(\"S\", tile.x + 10, tile.y + 20);\r\n\r\n                });\r\n            }\r\n\r\n            let edges;\r\n            let key;\r\n            if (debug === 3) {\r\n                key = \"traversable\";\r\n                edges = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"convertTileMapToPolyMap\"])(gs.get(\"screen_buffer\"), key, 0, 0, TM_WIDTH, TM_HEIGHT, TILE_SIZE, TM_WIDTH);\r\n                edges.forEach(edge => Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(edge.sx, edge.sy, edge.ex, edge.ey, context, \"blue\"));\r\n                const polygon = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"calculateVisibilityPolygon\"])(edges, x, y, 1000);\r\n                drawPolygonTriangles(x, y, polygon);\r\n\r\n                context.font = \"30px Arial\";\r\n                context.fillStyle = \"white\";\r\n                context.fillText(key, 20, 270);\r\n                context.fillText(\"Rays cast: \" + polygon.length, 20, 300);\r\n            }\r\n            if (debug === 2) {\r\n                key = \"seeable\";\r\n                edges = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"convertTileMapToPolyMap\"])(gs.get(\"screen_buffer\"), key, 0, 0, TM_WIDTH, TM_HEIGHT, TILE_SIZE, TM_WIDTH);\r\n                edges.forEach(edge => Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(edge.sx, edge.sy, edge.ex, edge.ey, context, \"blue\"));\r\n                const polygon = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"calculateVisibilityPolygon\"])(edges, x, y, 1000);\r\n                fillInversePolygon(polygon, \"black\");\r\n\r\n                context.font = \"30px Arial\";\r\n                context.fillStyle = \"white\";\r\n                context.fillText(key, 20, 270);\r\n                context.fillText(\"Rays cast: \" + polygon.length, 20, 300);\r\n            }\r\n            if (debug === 1) {\r\n                key = \"penetrable\";\r\n                edges = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"convertTileMapToPolyMap\"])(gs.get(\"screen_buffer\"), key, 0, 0, TM_WIDTH, TM_HEIGHT, TILE_SIZE, TM_WIDTH);\r\n                edges.forEach(edge => Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(edge.sx, edge.sy, edge.ex, edge.ey, context, \"blue\"));\r\n                const polygon = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"calculateVisibilityPolygon\"])(edges, x, y, 1000);\r\n                drawPolygonTriangles(x, y, polygon);\r\n\r\n                context.font = \"30px Arial\";\r\n                context.fillStyle = \"white\";\r\n                context.fillText(key, 20, 270);\r\n                context.fillText(\"Rays cast: \" + polygon.length, 20, 300);\r\n            }\r\n\r\n            context.font = \"30px Arial\";\r\n            context.fillStyle = \"white\";\r\n            context.fillText(\"\" + \"x: \" + x + \" y: \" + y + \" tx: \" + Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(x) + \" ty: \" + Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(y) + \", fps: \" + gs.get(\"fps\"), 0, 30);\r\n        }\r\n        function drawPolygonTriangles(xSource, ySource, polygon) {\r\n            // // Draw each triangle in fan\r\n            for (let i = 0; i < polygon.length - 1; i++) {\r\n                Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(xSource, ySource, polygon[i].min_px, polygon[i].min_py, context);\r\n                Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(xSource, ySource, polygon[i + 1].min_px, polygon[i + 1].min_py, context);\r\n                Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(polygon[i].min_px, polygon[i].min_py, polygon[i + 1].min_px, polygon[i + 1].min_py, context);\r\n            }\r\n            Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(xSource, ySource, polygon[0].min_px, polygon[0].min_py, context);\r\n            Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(xSource, ySource, polygon[polygon.length - 1].min_px, polygon[polygon.length - 1].min_py, context);\r\n            Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"drawLine\"])(polygon[polygon.length - 1].min_px, polygon[polygon.length - 1].min_py, polygon[0].min_px, polygon[0].min_py, context);\r\n\r\n        }\r\n\r\n        function fillInversePolygon(polygon, color) {\r\n            context.beginPath();\r\n            // set context styles\r\n            context.fillStyle = color;\r\n            context.moveTo(0, 0);\r\n            context.lineTo(0, WINDOW_HEIGHT);\r\n            context.lineTo(WINDOW_WIDTH, WINDOW_HEIGHT);\r\n            context.lineTo(WINDOW_WIDTH, 0);\r\n            context.lineTo(0, 0);\r\n            context.closePath();\r\n\r\n            // context.globalCompositeOperation = \"lighter\"; // spaciger look\r\n            context.moveTo(polygon[0].min_px, polygon[0].min_py);\r\n            polygon.forEach(p => {\r\n                context.lineTo(p.min_px, p.min_py);\r\n            });\r\n            context.lineTo(polygon[0].min_px, polygon[0].min_py);\r\n            context.closePath(); // automatically moves back to bottom left corner\r\n            context.fill();\r\n        }\r\n\r\n        // draw entities\r\n        gs.get(\"entities\").forEach(e => {\r\n            // // friendlies haben damit immer an circle drum herum\r\n            if (e.friendly === 1) context.strokeStyle = \"blue\";\r\n            else if (e.friendly === -1) context.strokeStyle = \"red\";\r\n            // else return; // if neither friendly or not friendly, dont draw circle\r\n\r\n            // set occupied on tiles\r\n            let i = Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"getTileIndex\"])(e.x, e.y);\r\n            if (gs.get(\"screen_buffer\", i))\r\n                gs.get(\"screen_buffer\", i).occupied = true;\r\n\r\n            // vll a drawEntity(), de dann zb sich um die sprite walking animation k√ºmmert\r\n            drawSprite(e, context);\r\n        });\r\n\r\n        // draw highlighted tiles (h√§tt des links halten und path ziehen sein sollen)\r\n        // for (let i = 0; i < preview.length; i++) {\r\n        //     context.beginPath();\r\n        //     context.rect(preview[i].x, preview[i].y, TILE_SIZE, TILE_SIZE);\r\n        //     context.stroke();\r\n        // }\r\n\r\n        // draw current selection window (current top right tile) and rectangular highlight\r\n        if (gs.get(\"currentSelection\")) {\r\n            const { x, y, friendly, range } = gs.get(\"currentSelection\");\r\n\r\n            // draw rectangle around selected tile\r\n            if (friendly === -1) context.strokeStyle = \"red\";\r\n            else if (friendly === 1) context.strokeStyle = \"blue\";\r\n            else context.strokeStyle = \"#222\";\r\n            \r\n            context.beginPath();\r\n            \r\n            // check if entity or tile\r\n            if (range) context.arc(Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(x) * TILE_SIZE + TILE_SIZE / 2, Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(y) * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2, 0, 2 * Math.PI);\r\n            else context.rect(Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(x) * TILE_SIZE, Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(y) * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n            context.stroke();\r\n\r\n            // if attack mode, draw range\r\n            if (gs.get(\"mode\") === _constants_js__WEBPACK_IMPORTED_MODULE_3__[\"ATTACK_MODE\"]) {\r\n                Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"getTilesWithinDistance\"])(x, y, range).forEach(tile => {\r\n                    context.beginPath();\r\n                    context.rect(tile.x, tile.y, TILE_SIZE, TILE_SIZE);\r\n                    context.stroke();\r\n                });\r\n            }\r\n\r\n            // draw selection window\r\n            context.font = \"12px Arial\";\r\n            context.fillStyle = \"#eee\";\r\n            context.fillRect(530, 340, WINDOW_WIDTH, WINDOW_HEIGHT);\r\n            const { movementSpeed, movementCost, name, traversable, occupied, attack } = gs.get(\"currentSelection\");\r\n            context.fillStyle = \"#222\";\r\n            context.fillText(name, 540, 365);\r\n            context.font = \"10px Arial\";\r\n            context.fillText(\"MOV: \" + (movementSpeed || movementCost), 540, 390);\r\n            if (movementSpeed) { // if entity\r\n                context.fillText(\"ATK: \" + (attack), 540, 410);\r\n                context.fillText(\"RNG: \" + (range), 540, 430);\r\n            } else {\r\n                context.fillText(\"TRA: \" + (traversable), 540, 410);\r\n                context.fillText(\"OCC: \" + (occupied), 540, 430);\r\n            }\r\n            drawSprite(gs.get(\"currentSelection\"), context, WINDOW_WIDTH - 30, 350);\r\n\r\n\r\n        }\r\n\r\n        // gs.get(\"overlays\").length > 0 && console.log(\"ol:\", gs.get(\"overlays\").length);\r\n        if (gs.get(\"overlays\") && gs.get(\"overlays\").length > 0) {\r\n            context.strokeStyle = \"#1aa\";\r\n            context.beginPath();\r\n            gs.get(\"overlays\").forEach(o => o.animate ? drawSprite(o, context) : context.rect(o.x, o.y, TILE_SIZE, TILE_SIZE));\r\n            context.stroke();\r\n        }\r\n\r\n        if (gs.get(\"mousePos\")) {\r\n            const { x, y } = gs.get(\"mousePos\");\r\n            if (gs.get(\"mode\") === _constants_js__WEBPACK_IMPORTED_MODULE_3__[\"ATTACK_MODE\"]) context.strokeStyle = \"red\";\r\n            if (gs.get(\"mode\") === _constants_js__WEBPACK_IMPORTED_MODULE_3__[\"STANDARD_MODE\"]) context.strokeStyle = \"blue\";\r\n            context.beginPath();\r\n            context.rect(Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(x) * TILE_SIZE, Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"toTileSize\"])(y) * TILE_SIZE, TILE_SIZE, TILE_SIZE);\r\n            context.stroke();\r\n        }\r\n\r\n        // weather particle try\r\n        // des w√§r ohne a weatherParticles array\r\n        // for (let y = 0; y < TM_HEIGHT; y++) {\r\n        //     for (let x = 0; x < TM_WIDTH; x++) {\r\n        //         // if (rand(2) === 1) {\r\n        //         //     drawSprite(screen_buffer[0], context, x * TILE_SIZE, y * TILE_SIZE);\r\n        //         // }\r\n        //         const coord_x = rand(TILE_SIZE) + TILE_SIZE * x;\r\n        //         const coord_y = rand(TILE_SIZE) + TILE_SIZE * y;\r\n        //         const size = rand(2) + 1;\r\n        //         context.fillRect(coord_x, 0 + y*x, size, size);\r\n        //     }\r\n        // }\r\n\r\n        // weather effects\r\n        // needs global lightning variable\r\n        // if (!lightning && rand(200) === 1) lightning = (rand(4) + 1) * 5;\r\n        // if (lightning || lightning === 0) {\r\n        //     if (lightning % 6 === 5) context.fillStyle = \"#fff\";\r\n        //     if (lightning % 6 === 4) context.fillStyle = \"#eee\";\r\n        //     if (lightning % 6 === 3) context.fillStyle = \"#ddd\";\r\n        //     if (lightning % 6 === 2) context.fillStyle = \"#aaa\";\r\n        //     if (lightning % 6 === 1) context.fillStyle = \"#000\";\r\n        //     if (lightning % 6 === 0) context.fillStyle = \"#555\";\r\n        //     screen_buffer.forEach(tile => context.fillRect(tile.x, tile.y, TILE_SIZE, TILE_SIZE))\r\n        //     lightning = lightning < 1 ? false : lightning - 1;\r\n        // }\r\n\r\n        // // des braucht a weatherParticles array\r\n        // for (let i = 0; i < weatherParticles.length; i++) {\r\n        //     if (weatherParticles[i].y > WINDOW_HEIGHT) {\r\n        //         weatherParticles[i].y = 0;\r\n        //     }\r\n        //     if (weatherParticles[i].x > WINDOW_WIDTH) {\r\n        //         weatherParticles[i].x = 0;\r\n        //     }\r\n        //     context.fillStyle = \"#19a\";\r\n        //     context.fillRect(weatherParticles[i].x += 1, weatherParticles[i].y += 10, 1, 30);\r\n        // }\r\n\r\n        window.requestAnimationFrame(update);\r\n    }\r\n\r\n    /**\r\n     * Takes any game object (entity, tile, etc) and draws the corresponding sprite to its position.\r\n     * @param {*} gameObject - any tile or entity\r\n     * @param {*} ctx - context to draw to (multiple canvases)\r\n     * @param {*} overrideX - override target x coordinate\r\n     * @param {*} overrideY - override target y coordinate\r\n     * eig sollts wohl so aufgrufen werden: drawSprite(tile.x, tile.y)\r\n     */\r\n    function drawSprite(gameObject, ctx, overrideX, overrideY) { // besserer name statt gameObject ha\r\n        if (!gameObject || !ctx) {\r\n            console.error(\"drawSprite(): Insufficient params\");\r\n            gameObject && console.log(gameObject);\r\n            return;\r\n        }\r\n        const { color, sprite } = gameObject;\r\n        const x = overrideX >= 0 ? overrideX : gameObject.x;\r\n        const y = overrideY >= 0 ? overrideY : gameObject.y;\r\n        // context.drawImage(image, image-offset.x, image-offset.y, image.width canvas.x, canvas.y);\r\n        if (gameObject) {\r\n            if (sprite) {\r\n                ctx.drawImage(spriteSheet, TILE_SIZE * sprite.x, TILE_SIZE * sprite.y, TILE_SIZE, TILE_SIZE, x, y, TILE_SIZE, TILE_SIZE);\r\n            } else {\r\n                ctx.fillstyle = color;\r\n                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/cowboy.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cowboy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cowboy.js */ \"./src/cowboy.js\");\n\r\n\r\n// globals used pretty much everywhere\r\nwindow.WINDOW_WIDTH = 640; // 2048 | 640; // 640 / 20 = 32\r\nwindow.WINDOW_HEIGHT = 480 // 1536 | 480; // 480 / 20 = 24\r\nwindow.PIXEL_SIZE = 1;\r\nwindow.TILE_SIZE = 20 ; // in my pixel\r\nwindow.TM_WIDTH = WINDOW_WIDTH / TILE_SIZE; // TILEMAP WIDTH\r\nwindow.TM_HEIGHT = WINDOW_HEIGHT / TILE_SIZE; // TILEMAP HEIGHT\r\n\r\n\r\nwindow.onload = () => {\r\n    Object(_cowboy_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n}\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: convert1dto2d, getIndex, getTileIndex, toTileSize, rand, getTileDistance, isInBounds, pythagoras, getTilesWithinDistance, convertTileMapToPolyMap, calculateVisibilityPolygon, getShortestPath, drawLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convert1dto2d\", function() { return convert1dto2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIndex\", function() { return getIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTileIndex\", function() { return getTileIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toTileSize\", function() { return toTileSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rand\", function() { return rand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTileDistance\", function() { return getTileDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInBounds\", function() { return isInBounds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pythagoras\", function() { return pythagoras; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTilesWithinDistance\", function() { return getTilesWithinDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertTileMapToPolyMap\", function() { return convertTileMapToPolyMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateVisibilityPolygon\", function() { return calculateVisibilityPolygon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShortestPath\", function() { return getShortestPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawLine\", function() { return drawLine; });\n// util\r\nfunction convert1dto2d(i, width) {\r\n    return {\r\n        x: i % width,\r\n        y: Math.floor(i / width)\r\n    };\r\n}\r\n\r\n/**\r\n * Takes any 2d pixel coordinates and returns the 1d index specified be width.\r\n * @param {Number} x \r\n * @param {Number} y \r\n * @param {Number} width \r\n */\r\nfunction getIndex(x, y, width = WINDOW_WIDTH) {\r\n    return x + width * y;\r\n}\r\n\r\n/**\r\n * Takes any 2d pixel coordinates and returns the 1d tile index.\r\n * @param {Number} x \r\n * @param {Number} y \r\n */\r\nfunction getTileIndex(x, y) {\r\n    return getIndex(toTileSize(x), toTileSize(y), TM_WIDTH);\r\n}\r\n\r\nfunction toTileSize(n) {\r\n    return Math.floor(n / TILE_SIZE);\r\n}\r\n\r\n/**\r\n * Returns a random integer between 0 and n-1.\r\n * @param {Number} n \r\n */\r\nfunction rand(n) {\r\n    return Math.floor(Math.random() * n);\r\n}\r\n/**\r\n * Calculate distance between two points and return in tile units.\r\n * \r\n * Es k√∂nnt insofern besser sein bei die echten Koordinaten zu bleiben, da getTileDistance viel dividiert.\r\n * Da gro√üe Unterschied is, dass ma dann beim range-check (range * TILE_SIZE) machen m√ºssen: \r\n * if (getDistance(x, y, e.x, e.y) < range * TILE_SIZE) vs\r\n * if (getTileDistance(x, y, e.x, e.y) < range) \r\n * @param {Number} x1 \r\n * @param {Number} y1 \r\n * @param {Number} x2 \r\n * @param {Number} y2 \r\n */\r\nfunction getTileDistance(x1, y1, x2, y2) {\r\n    const dx = toTileSize(x2) - toTileSize(x1);\r\n    const dy = toTileSize(y2) - toTileSize(y1);\r\n    return Math.sqrt(pythagoras(dx, dy));\r\n}\r\n\r\n/**\r\n * In actual pixels, not tiles!\r\n * @param {*} x \r\n * @param {*} y \r\n */\r\nfunction isInBounds(x, y) {\r\n    return (\r\n        (0 <= x && x < WINDOW_WIDTH) &&\r\n        (0 <= y && y < WINDOW_HEIGHT)\r\n    );\r\n}\r\n\r\n/**\r\n * Returns distance of hypotenuse squared.\r\n * @param {Number} a \r\n * @param {Number} b \r\n */\r\nfunction pythagoras(a, b) {\r\n    return a * a + b * b;\r\n}\r\n\r\n/**\r\n * returns array of tiles within given range\r\n * @param {Number} x  - in pixel units\r\n * @param {Number} y - in pixel units\r\n * @param {Number} range - in tile units\r\n */\r\nfunction getTilesWithinDistance(x, y, range) {\r\n    const tilesInRange = [];\r\n    for (let i = -range; i < range; i++) {\r\n        for (let j = -range; j < range; j++) {\r\n            const targetX = x + i * TILE_SIZE;\r\n            const targetY = y + j * TILE_SIZE;\r\n\r\n            if (\r\n                isInBounds(targetX, targetY) && (\r\n                    // if x and y is smaller than our range - (range / 5), it is in range\r\n                    (Math.abs(i) < range - (range / 5) && Math.abs(j) < range - (range / 5)) ||\r\n                    getTileDistance(x, y, targetX, targetY) < range\r\n                )\r\n            ) {\r\n                // it should not include duplicates (overlapping regions of vision), but does\r\n                tilesInRange.push({ x: targetX, y: targetY });\r\n            }\r\n        }\r\n    }\r\n    return tilesInRange;\r\n}\r\n\r\n\r\n// ------------ EDGE DETECTION ___________\r\nfunction sEdge() {\r\n    return {\r\n        sx: 0, sy: 0, // Start coordinate\r\n        ex: 0, ey: 0 // End coordinate\r\n    };\r\n}\r\n\r\nfunction sCell() {\r\n    return {\r\n        edge_id: [],\r\n        edge_exist: [],\r\n        exist: false\r\n    };\r\n}\r\n\r\nconst NORTH = 0;\r\nconst SOUTH = 1;\r\nconst EAST = 2;\r\nconst WEST = 3;\r\n\r\n/**\r\n * Takes a tile map in 1d and returns an array of edges.\r\n * Heavily inspired by Javidx9's video on ray casting. \r\n * Line Of Sight or Shaodw Casting in 2D: https://www.youtube.com/watch?v=fc3nnG2CG8U\r\n * @param {Object} tilemap \r\n * @param {String} key - the field of the tile to check for \r\n * @param {*} sx - start coordinates\r\n * @param {*} sy - start coordinates\r\n * @param {*} w - tilemap width\r\n * @param {*} h - tilemap height\r\n * @param {*} fBlockWidth - tile size\r\n * @param {*} pitch - tile size (warum auch immer)\r\n */\r\nfunction convertTileMapToPolyMap(tilemap, key, sx, sy, w, h, fBlockWidth, pitch) {\r\n    \"use strict\";\r\n    const world = [];\r\n\r\n    const edges = [];\r\n\r\n    for (let x = 0; x < w; x++)\r\n        for (let y = 0; y < h; y++)\r\n            for (let j = 0; j < 4; j++) {\r\n                const cell = sCell();\r\n                cell.edge_exist[j] = false;\r\n                cell.edge_id[j] = 0;\r\n                world[(y + sy) * pitch + (x + sx)] = cell;\r\n            }\r\n\r\n    // Iterate through region from top left to bottom right\r\n    for (let x = 1; x < w - 1; x++)\r\n        for (let y = 1; y < h - 1; y++) {\r\n            // Create some convenient indices\r\n            const i = (y + sy) * pitch + (x + sx);\t\t\t// This\r\n            const n = (y + sy - 1) * pitch + (x + sx);\t\t// Northern Neighbour\r\n            const s = (y + sy + 1) * pitch + (x + sx);\t\t// Southern Neighbour\r\n            const w = (y + sy) * pitch + (x + sx - 1);\t// Western Neighbour\r\n            const e = (y + sy) * pitch + (x + sx + 1);\t// Eastern Neighbour\r\n\r\n            // If this cell exists, check if it needs edges\r\n            if (tilemap[i][key]) {\r\n                world[i].exist = true;\r\n                // If this cell has no western neighbour, it needs a western edge\r\n                if (!tilemap[w][key]) {\r\n                    // It can either extend it from its northern neighbour if they have\r\n                    // one, or It can start a new one.\r\n                    if (world[n].edge_exist[WEST]) {\r\n                        // Northern neighbour has a western edge, so grow it downwards\r\n                        edges[world[n].edge_id[WEST]].ey += fBlockWidth;\r\n                        world[i].edge_id[WEST] = world[n].edge_id[WEST];\r\n                        world[i].edge_exist[WEST] = true;\r\n                    }\r\n                    else {\r\n                        // Northern neighbour does not have one, so create one\r\n                        const edge = sEdge();\r\n                        edge.sx = (sx + x) * fBlockWidth; edge.sy = (sy + y) * fBlockWidth;\r\n                        edge.ex = edge.sx; edge.ey = edge.sy + fBlockWidth;\r\n\r\n                        // Add edge to Polygon Pool\r\n                        const edge_id = edges.length;\r\n                        edges.push(edge);\r\n\r\n                        // Update tile information with edge information\r\n                        world[i].edge_id[WEST] = edge_id;\r\n                        world[i].edge_exist[WEST] = true;\r\n                    }\r\n                }\r\n\r\n                // If this cell dont have an eastern neighbour, It needs a eastern edge\r\n                if (!tilemap[e][key]) {\r\n                    // It can either extend it from its northern neighbour if they have\r\n                    // one, or It can start a new one.\r\n                    if (world[n].edge_exist[EAST]) {\r\n                        // Northern neighbour has one, so grow it downwards\r\n                        edges[world[n].edge_id[EAST]].ey += fBlockWidth;\r\n                        world[i].edge_id[EAST] = world[n].edge_id[EAST];\r\n                        world[i].edge_exist[EAST] = true;\r\n                    }\r\n                    else {\r\n                        // Northern neighbour does not have one, so create one\r\n                        const edge = sEdge();\r\n                        edge.sx = (sx + x + 1) * fBlockWidth; edge.sy = (sy + y) * fBlockWidth;\r\n                        edge.ex = edge.sx; edge.ey = edge.sy + fBlockWidth;\r\n\r\n                        // Add edge to Polygon Pool\r\n                        const edge_id = edges.length;\r\n                        edges.push(edge);\r\n\r\n                        // Update tile information with edge information\r\n                        world[i].edge_id[EAST] = edge_id;\r\n                        world[i].edge_exist[EAST] = true;\r\n                    }\r\n                }\r\n\r\n                // If this cell doesnt have a northern neignbour, It needs a northern edge\r\n                if (!tilemap[n][key]) {\r\n                    // It can either extend it from its western neighbour if they have\r\n                    // one, or It can start a new one.\r\n                    if (world[w].edge_exist[NORTH]) {\r\n                        // Western neighbour has one, so grow it eastwards\r\n                        edges[world[w].edge_id[NORTH]].ex += fBlockWidth;\r\n                        world[i].edge_id[NORTH] = world[w].edge_id[NORTH];\r\n                        world[i].edge_exist[NORTH] = true;\r\n                    }\r\n                    else {\r\n                        // Western neighbour does not have one, so create one\r\n                        const edge = sEdge();\r\n                        edge.sx = (sx + x) * fBlockWidth; edge.sy = (sy + y) * fBlockWidth;\r\n                        edge.ex = edge.sx + fBlockWidth; edge.ey = edge.sy;\r\n\r\n                        // Add edge to Polygon Pool\r\n                        const edge_id = edges.length;\r\n                        edges.push(edge);\r\n\r\n                        // Update tile information with edge information\r\n                        world[i].edge_id[NORTH] = edge_id;\r\n                        world[i].edge_exist[NORTH] = true;\r\n                    }\r\n                }\r\n\r\n                // If this cell doesnt have a southern neignbour, It needs a southern edge\r\n                if (!tilemap[s][key]) {\r\n                    // It can either extend it from its western neighbour if they have\r\n                    // one, or It can start a new one.\r\n                    if (world[w].edge_exist[SOUTH]) {\r\n                        // Western neighbour has one, so grow it eastwards\r\n                        edges[world[w].edge_id[SOUTH]].ex += fBlockWidth;\r\n                        world[i].edge_id[SOUTH] = world[w].edge_id[SOUTH];\r\n                        world[i].edge_exist[SOUTH] = true;\r\n                    } else {\r\n                        // Western neighbour does not have one, so I need to create one\r\n                        const edge = sEdge();\r\n                        edge.sx = (sx + x) * fBlockWidth; edge.sy = (sy + y + 1) * fBlockWidth;\r\n                        edge.ex = edge.sx + fBlockWidth; edge.ey = edge.sy;\r\n\r\n                        // Add edge to Polygon Pool\r\n                        const edge_id = edges.length;\r\n                        edges.push(edge);\r\n\r\n                        // Update tile information with edge information\r\n                        world[i].edge_id[SOUTH] = edge_id;\r\n                        world[i].edge_exist[SOUTH] = true;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n    return edges;\r\n}\r\n\r\n/**\r\n * \r\n * Heavily inspired by Javidx9's video on ray casting. \r\n * Line Of Sight or Shaodw Casting in 2D: https://www.youtube.com/watch?v=fc3nnG2CG8U\r\n * @param {*} edges \r\n * @param {*} ox \r\n * @param {*} oy \r\n * @param {*} radius \r\n */\r\nfunction calculateVisibilityPolygon(edges, ox, oy, radius) {\r\n    // Get rid of existing polygon\r\n    const polygon = [];\r\n\r\n    // For each edge in PolyMap\r\n    for (let i = 0; i < edges.length; i++) {\r\n        const e1 = edges[i];\r\n        // Take the start point, then the end point (we could use a pool of\r\n        // non-duplicated points here, it would be more optimal)\r\n        for (let i = 0; i < 2; i++) {\r\n            let rdx, rdy;\r\n            rdx = (i == 0 ? e1.sx : e1.ex) - ox;\r\n            rdy = (i == 0 ? e1.sy : e1.ey) - oy;\r\n\r\n            const base_ang = Math.atan2(rdy, rdx);\r\n\r\n            let ang = 0;\r\n            // For each point, cast 3 rays, 1 directly at point\r\n            // and 1 a little bit either side\r\n            for (let j = 0; j < 3; j++) {\r\n                if (j == 0) ang = base_ang - 0.0001;\r\n                if (j == 1) ang = base_ang;\r\n                if (j == 2) ang = base_ang + 0.0001;\r\n\r\n                // Create ray along angle for required distance\r\n                rdx = radius * Math.cos(ang);\r\n                rdy = radius * Math.sin(ang);\r\n\r\n                let min_t1 = Infinity;\r\n                let min_px = 0, min_py = 0, min_ang = 0;\r\n                let bValid = false;\r\n\r\n                // Check for ray intersection with all edges\r\n                for (let j = 0; j < edges.length; j++) {\r\n                    const e2 = edges[j];\r\n                    // Create line segment vector\r\n                    const sdx = e2.ex - e2.sx;\r\n                    const sdy = e2.ey - e2.sy;\r\n\r\n                    // ensure that both edges are reasonably different. They could be identical\r\n                    // and thus produce infinite solutions.\r\n                    if (Math.abs(sdx - rdx) > 0.0 && Math.abs(sdy - rdy) > 0.0) {\r\n                        // t2 is normalised distance from line segment start to line segment end of intersect point\r\n                        const t2 = (rdx * (e2.sy - oy) + (rdy * (ox - e2.sx))) / (sdx * rdy - sdy * rdx);\r\n                        // t1 is normalised distance from source along ray to ray length of intersect point\r\n                        const t1 = (e2.sx + sdx * t2 - ox) / rdx;\r\n\r\n                        // If intersect point exists along ray, and along line \r\n                        // segment then intersect point is valid\r\n                        if (t1 > 0 && t2 >= 0 && t2 <= 1.0) {\r\n                            // Check if this intersect point is closest to source. If\r\n                            // it is, then store this point and reject others\r\n                            if (t1 < min_t1) {\r\n                                min_t1 = t1;\r\n                                min_px = ox + rdx * t1;\r\n                                min_py = oy + rdy * t1;\r\n                                min_ang = Math.atan2(min_py - oy, min_px - ox);\r\n                                bValid = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (bValid)// Add intersection point to visibility polygon perimeter\r\n                    polygon.push({ min_ang, min_px, min_py });\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sort perimeter points by angle from source. This will allow\r\n    // us to draw a triangle fan.\r\n    return polygon.sort((a, b) => a.min_ang - b.min_ang);\r\n\r\n}\r\n\r\n\r\nfunction getShortestPath(tilemap, sx, sy, ex, ey) {\r\n    const path = [];\r\n\r\n    // tilemap\r\n\r\n    return path;\r\n}\r\n\r\nfunction drawLine(sx, sy, ex, ey, context, color) {\r\n    if (color) context.strokeStyle = color;\r\n    context.beginPath();\r\n    context.moveTo(sx, sy);\r\n    context.lineTo(ex, ey);\r\n    context.stroke();\r\n\r\n}\r\n\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ })

/******/ });